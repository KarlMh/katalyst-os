use core::ptr;
use spin::Mutex;
use lazy_static::lazy_static;
use bootloader::BootInfo;
use conquer_once::spin::OnceCell;

pub static BOOT_INFO: OnceCell<&'static BootInfo> = OnceCell::uninit();
//
// PIXEL TYPE
//
#[derive(Clone, Copy)]
pub struct Pixel(pub u8, pub u8, pub u8);

//
// FRAMEBUFFER WRITER
//
pub struct FramebufferWriter {
    pub buffer: *mut u8,
    pub width: usize,
    pub height: usize,
    pub pitch: usize, // bytes per row
    pub cursor_x: usize,
    pub cursor_y: usize,
}

impl FramebufferWriter {
    pub fn new(buffer: *mut u8, width: usize, height: usize, pitch: usize) -> Self {
        Self { buffer, width, height, pitch, cursor_x: 0, cursor_y: 0 }
    }

    pub fn draw_pixel(&mut self, x: usize, y: usize, color: Pixel) {
        if x >= self.width || y >= self.height { return; }
        let Pixel(r, g, b) = color;
        let index = y * self.pitch + x * 3;
        unsafe {
            *self.buffer.add(index) = r;
            *self.buffer.add(index + 1) = g;
            *self.buffer.add(index + 2) = b;
        }
    }

    pub fn clear(&mut self, color: Pixel) {
        let Pixel(r, g, b) = color;
        for y in 0..self.height {
            for x in 0..self.width {
                let index = (y * self.width + x) * 3;
                unsafe {
                    *self.buffer.add(index) = r;
                    *self.buffer.add(index + 1) = g;
                    *self.buffer.add(index + 2) = b;
                }
            }
        }
    }

    pub fn draw_char(&mut self, ch: char, bold: bool, italic: bool) {
        let code = ch as usize & 0x7F; // ASCII only
        let glyph = FONT8x8[code];

        for (y, row) in glyph.iter().enumerate() {
            for bit in 0..8 {
                if (row >> (7 - bit)) & 1 == 1 {
                    let mut px = self.cursor_x + bit;
                    let py = self.cursor_y + y;

                    if italic {
                        px += y / 2;
                    }

                    self.draw_pixel(px, py, Pixel(255, 255, 255));
                    if bold {
                        self.draw_pixel(px + 1, py, Pixel(255, 255, 255));
                    }
                }
            }
        }

        self.cursor_x += 8 + if bold { 1 } else { 0 };
    }

    pub fn draw_text(&mut self, text: &str, bold: bool, italic: bool) {
        for ch in text.chars() {
            if ch == '\n' {
                self.newline(1);
            } else {
                self.draw_char(ch, bold, italic);
            }
        }
    }

    pub fn newline(&mut self, lines: usize) {
        self.cursor_y += lines * 12;
        self.cursor_x = 0;
    }
}

unsafe impl Send for FramebufferWriter {}
unsafe impl Sync for FramebufferWriter {}

//
// GLOBAL WRITER
//
lazy_static! {
    pub static ref FB_WRITER: Mutex<Option<FramebufferWriter>> = Mutex::new(None);
}

//
// INITIALIZE FRAMEBUFFER
//
pub fn init_framebuffer(boot_info: &'static BootInfo) {
    // Define resolution and bytes per pixel
    const WIDTH: usize = 1024;
    const HEIGHT: usize = 768;
    const BYTES_PER_PIXEL: usize = 3;

    let pitch = WIDTH * BYTES_PER_PIXEL;

    // Allocate a linear framebuffer in memory
    // We just pick a safe physical address (must be usable in memory map)
    let fb_phys_addr: u64 = 0xE000_0000; // 3.5 GB mark, typical for OS experimentation
    let fb_ptr = (fb_phys_addr + boot_info.physical_memory_offset) as *mut u8;

    // Zero it out
    unsafe {
        for i in 0..(WIDTH * HEIGHT * BYTES_PER_PIXEL) {
            fb_ptr.add(i).write_volatile(0);
        }
    }

    // Create the framebuffer writer
    let mut fb_lock = FB_WRITER.lock();
    *fb_lock = Some(FramebufferWriter::new(fb_ptr, WIDTH, HEIGHT, pitch));
}

//
// 8x8 BITMAP ASCII FONT
//  - full table (128 entries)
//  - unknown chars = simple box
//
pub static FONT8x8: [[u8; 8]; 128] = [
    // 0–31: control chars → blank
    [0; 8], [0; 8], [0; 8], [0; 8], [0; 8], [0; 8], [0; 8], [0; 8],
    [0; 8], [0; 8], [0; 8], [0; 8], [0; 8], [0; 8], [0; 8], [0; 8],
    [0; 8], [0; 8], [0; 8], [0; 8], [0; 8], [0; 8], [0; 8], [0; 8],
    [0; 8], [0; 8], [0; 8], [0; 8], [0; 8], [0; 8], [0; 8], [0; 8],

    // 32: space
    [0; 8],

    // 33–47: punctuation → simple box
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // !
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // "
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // #
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // $
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // %
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // &
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // '
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // (
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // )
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // *
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // +
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // ,
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // -
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // .
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // /

    // 48–57: 0–9 (real glyphs)
    [0x3E,0x45,0x49,0x51,0x3E,0,0,0], // 0
    [0x00,0x21,0x7F,0x01,0x00,0,0,0], // 1
    [0x23,0x45,0x49,0x51,0x21,0,0,0], // 2
    [0x41,0x49,0x49,0x49,0x36,0,0,0], // 3
    [0x0C,0x14,0x24,0x7F,0x04,0,0,0], // 4
    [0x72,0x49,0x49,0x49,0x46,0,0,0], // 5
    [0x3E,0x49,0x49,0x49,0x26,0,0,0], // 6
    [0x40,0x47,0x48,0x50,0x60,0,0,0], // 7
    [0x36,0x49,0x49,0x49,0x36,0,0,0], // 8
    [0x32,0x49,0x49,0x49,0x3E,0,0,0], // 9

    // 58–64: punctuation → box
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // :
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // ;
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // <
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // =
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // >
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // ?
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // @

    // 65–90: A–Z (real glyphs)
    [0x7C,0x12,0x11,0x12,0x7C,0,0,0], // A
    [0x7F,0x49,0x49,0x49,0x36,0,0,0], // B
    [0x3E,0x41,0x41,0x41,0x22,0,0,0], // C
    [0x7F,0x41,0x41,0x22,0x1C,0,0,0], // D
    [0x7F,0x49,0x49,0x49,0x41,0,0,0], // E
    [0x7F,0x09,0x09,0x09,0x01,0,0,0], // F
    [0x3E,0x41,0x49,0x49,0x7A,0,0,0], // G
    [0x7F,0x08,0x08,0x08,0x7F,0,0,0], // H
    [0x41,0x41,0x7F,0x41,0x41,0,0,0], // I
    [0x20,0x40,0x41,0x3F,0x01,0,0,0], // J
    [0x7F,0x08,0x14,0x22,0x41,0,0,0], // K
    [0x7F,0x40,0x40,0x40,0x40,0,0,0], // L
    [0x7F,0x02,0x0C,0x02,0x7F,0,0,0], // M
    [0x7F,0x04,0x08,0x10,0x7F,0,0,0], // N
    [0x3E,0x41,0x41,0x41,0x3E,0,0,0], // O
    [0x7F,0x09,0x09,0x09,0x06,0,0,0], // P
    [0x3E,0x41,0x51,0x21,0x5E,0,0,0], // Q
    [0x7F,0x09,0x19,0x29,0x46,0,0,0], // R
    [0x46,0x49,0x49,0x49,0x31,0,0,0], // S
    [0x01,0x01,0x7F,0x01,0x01,0,0,0], // T
    [0x3F,0x40,0x40,0x40,0x3F,0,0,0], // U
    [0x1F,0x20,0x40,0x20,0x1F,0,0,0], // V
    [0x7F,0x20,0x18,0x20,0x7F,0,0,0], // W
    [0x63,0x14,0x08,0x14,0x63,0,0,0], // X
    [0x07,0x08,0x70,0x08,0x07,0,0,0], // Y
    [0x61,0x51,0x49,0x45,0x43,0,0,0], // Z

    // 91–96 → box glyph
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // [
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // backslash
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // ]
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // ^
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // _
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // `

    // 97–122: a–z → box glyphs for now
    // (you can later replace with real lowercase drawings)
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // a
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // b
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // c
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // d
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // e
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // f
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // g
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // h
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // i
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // j
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // k
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // l
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // m
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // n
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // o
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // p
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // q
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // r
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // s
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // t
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // u
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // v
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // w
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // x
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // y
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // z

    // 123–127 → box glyphs
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // {
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // |
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // }
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // ~
    [0x7E,0x42,0x42,0x42,0x42,0x42,0x7E,0], // DEL 127
];
